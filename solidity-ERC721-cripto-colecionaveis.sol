Cap√≠tulo 1: Tokens no Ethereum

Vamos falar sobre tokens.

Se voc√™ esteve acompanhando o Ethereum por per√≠odo de tempo, voc√™ provavelmente ouviu pessoas falando sobre tokens - especificamente ERC20 tokens.

Um token no Ethereum √© basicamente um smart contract (contrato inteligente) que segue algumas regras comuns ‚Äî isto √©, ele implementa um conjunto padr√£o de fun√ß√µes que todos os outros contratos de token compartilham, como o transfer(address _to, uint256 _value) e balanceOf(address _owner).

Internamente o smart contract normalmente tem um mapeamento, mapping(address => uint256) balances, que mant√™m o registro de quanto em saldo cada endere√ßo tem.

Ent√£o basicamente um token √© somente contrato que mantem o registro de quem √© o dono desse token, e algumas fun√ß√µes, ent√£o esses usu√°rios podem transferir seus tokens para outros endere√ßos.
Por que isso importa?

Uma vez que todo token ERC20 compartilha o mesmo conjunto de fun√ß√µes com os mesmos nomes, todos eles podem interagir da mesma maneira.

Isto significa se voc√™ construir uma aplica√ß√£o que √© capaz de interagir com um token ERC20, ela ser√° capaz de interagir com qualquer token ERC20. Deste jeito mais tokens podem facilmente serem adicionados a sua aplica√ß√£o no futuro sem a necessidade the qualquer c√≥digo customizado. Voc√™ pode simples plugar um novo contrato de token.

Um exemplo disso poderia ser uma exchange. Quando uma exchange adiciona um novo token ERC20, na verdade ela s√≥ precisa adicionar um outro smart contract para funcionar. Usu√°rios podem dizer para este contrato enviar tokens para o endere√ßo da carteira da exchange, e a exchange pode dizer ao contrato para enviar os tokens de volta para os usu√°rios quando eles requisitarem um saque.

A exchange s√≥ precisa implementar esta l√≥gica da transfer√™ncia uma vez, ent√£o quando quiser adicionar um novo token ERC20, √© simplesmente um problema de adicionar um novo endere√ßo de contrato no banco de dados.
Outros padr√µes de token

Tokens ERC20 s√£o realmente legais para tokens que agem como moedas. Mas eles n√£o s√£o particularmente √∫teis para representar zumbis em nosso jogo de zumbi.

Primeiro, zumbis n√£o s√£o divis√≠veis como moedas ‚Äî Eu posso enviar para voc√™ 0.237 ETH, mas transferir pra voc√™ 0.237 de um zumbi realmente n√£o faz sentido algum.

Segundo, todos os zumbis n√£o s√£o criados iguais. Seu zumbi N√≠vel 2 "Steve" √© totalmente diferente do meu zumbi N√≠vel 732 "H4XF13LD MORRIS üíØüíØüòéüíØüíØ". (Nem mesmo perto, Steve).

H√° um outro padr√£o de token que se encaixa bem melhor para cripto-colecion√°veis como CryptoZombies ‚Äì e eles chamados de tokens ERC721.

Tokens ERC721_ n√£o s√£o intercambi√°veis uma vez que cada um √© suposto para ser √∫nico, e n√£o divis√≠veis. Voc√™ somente pode troc√°-los em unidades inteiras, e cada um tem um ID √∫nico. Ent√£o esses se encaixam perfeitamente para fazer nossos zumbis troc√°veis.

    Note que usando um padr√£o como ERC721 tem o benef√≠cio que n√£o precisamos ter que implementar uma l√≥gica de leil√£o ou garantia dentro do nosso contrato que determina como os jogadores devem trocar / vender nossos zumbis. Se obedecer-mos a especifica√ß√£o, qualquer um poderia criar uma plataforma de troca para ativos cripto-colecion√°veis ERC721, e nossos zumbis ERC721 seriam utiliz√°veis nesta plataforma. Ent√£o os benef√≠cios s√£o claros de usar um padr√£o de token ao inv√©s de criar a sua pr√≥pria l√≥gica de trocas.



Cap√≠tulo 2: Padr√£o ERC721, M√∫ltipla Heran√ßa

Vamos dar uma olhada no padr√£o ERC721:

contract ERC721 {
  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);
  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);

  function balanceOf(address _owner) public view returns (uint256 _balance);
  function ownerOf(uint256 _tokenId) public view returns (address _owner);
  function transfer(address _to, uint256 _tokenId) public;
  function approve(address _to, uint256 _tokenId) public;
  function takeOwnership(uint256 _tokenId) public;
}

Esta √© a lista de m√©todos que precisamos implementar, que iremos fazer em partes nos pr√≥ximos cap√≠tulos.

Isso parece um monte, mas sinta-se sobrecarregado! Estamos aqui para guiar voc√™.

    Nota: O padr√£o ERC721 √© atualmente um rascunho, e ainda n√£o h√° oficialmente um acordo de implementa√ß√£o. Neste tutorial usamos a vers√£o atual da biblioteca do OpenZeppelin, mas √© poss√≠vel que mude no futuro antes do lan√ßamento oficial. Ent√£o considere esta uma poss√≠vel implementa√ß√£o, mas n√£o considere uma vers√£o oficial dos tokens ERC721.

Implementando um contrato de token

Quando implementar um contrato de token, a primeira coisa que fazemos √© copiar a interface para o nosso pr√≥prio arquivo Solidity e import√°-lo. import "./erc721.sol";. Ent√£o n√≥s teremos o nosso contrato herdando-o, e iremos sobrepor cada m√©todo com a defini√ß√£o da fun√ß√£o.

Mas espere ‚Äì ZombieOwnership j√° esta herdando do ZombieAttack ‚Äì como pode tamb√©m herdar do ERC721?

Para a nossa sorte em Solidity, seu contrato pode herdar de m√∫ltiplos contrato conforme segue:

contract SatoshiNakamoto is NickSzabo, HalFinney {
  // Meu deus, os segredos do universo foram revelados!
}

Como voc√™ pode ver, quando usando a m√∫ltipla heran√ßa, voc√™ pode separar os m√∫ltiplos contrato que voc√™ estar herdando com um v√≠rgula, ,. Neste caso, nosso contrato esta herdando de NickSzabo e HalFinney.



Cap√≠tulo 3: balanceOf & ownerOf

√ìtimo, vamos mergulhar na implementa√ß√£o do ERC721!

J√° sa√≠mos na frente e copiamos uma casca vazia de todos as fun√ß√µes que voc√™ ir√° implementar nesta li√ß√£o.

Neste cap√≠tulos, iremos implementar os dois primeiros m√©todos: balanceOf e ownerOf.
balanceOf

  function balanceOf(address _owner) public view returns (uint256 _balance);

Esta fun√ß√£o simplesmente recebe um address, e retorna quantos tokens que o address tem.

Em nosso caso, nossos "tokens" s√£o Zumbis. Voc√™ lembra onde em nossa DApp n√≥s guardamos quantos zumbis um dono tem?
ownerOf

  function ownerOf(uint256 _tokenId) public view returns (address _owner);

Esta fun√ß√£o recebe um token ID (em nosso caso, um ID Zumbi), e retorna o address da pessoa que o possui.

Novamente, esta √© muito f√°cil para implementar-mos, uma vez que j√° temos um mapping (mapeamento) em nossa DApp que guarda esta informa√ß√£o. Podemos implementar esta fun√ß√£o em uma linha, s√≥ uma declara√ß√£o de return.

    Nota: Lembre, uint256 √© equivalente √† uint. Est√°vamos usando uint em nosso c√≥digo at√© agora, mas n√≥s usamos uint256 aqui por que copiamos e colamos da especifica√ß√£o.

Cap√≠tulo 4: Refatorando

Opa! N√≥s introduzimos um erro em nosso c√≥digo que vai impedir de compilar. Voc√™ percebeu?

No cap√≠tulo anterior n√≥s definimos a fun√ß√£o chamada de ownerOf. Mas se voc√™ lembrar da Li√ß√£o 4, n√≥s tamb√©m criamos um modifier (modificador) com o mesmo nome, ownerOf, em zombiefeeding.sol.

Se voc√™ tentar compilar este c√≥digo, o compilador ir√° retornar um erro dizendo que voc√™ n√£o pode ter um modificador e uma fun√ß√£o com o mesmo nome.

Ent√£o devemos somente mudar o nome da fun√ß√£o em ZombieOwnership para qualquer coisa?

N√£o, n√£o podemos fazer isso!!! Lembre-se, estamos usando o token padr√£o ERC721, que significa que outros contratos ir√£o esperar que o nosso contrato tenha as fun√ß√µes com os nomes definidos exatamente. Isto √© o que faz estes padr√µes √∫teis ‚Äì se outro contrato sabe que nosso contrato √© compat√≠vel com ERC721, este pode simplesmente conversar conosco sem a necessidade de saber qualquer coisa sobre as nossas decis√µes de implementa√ß√£o interna.

Ent√£o significa que iremos ter que refatorar o nosso c√≥digo da Li√ß√£o 4 para mudar o nome do modifier para outra coisa.


Cap√≠tulo 5: ERC721: L√≥gica de Transfer√™ncia

√ìtimo, consertamos o conflito!

Agora iremos continuar nossa implementa√ß√£o do ERC721 olhando na transfer√™ncia de propriedade de uma pessoa para outra.

Note que a especifica√ß√£o ERC721 tem duas maneiras diferentes de transferir tokens:

function transfer(address _to, uint256 _tokenId) public;
function approve(address _to, uint256 _tokenId) public;
function takeOwnership(uint256 _tokenId) public;

    A primeira forma √© o dono do token chamar transfer com o address que ele quer transferir, e o _tokenId do token que ele quer transferir.

    A segunda forma √© o dono do token primeiro chama approve, e envia a mesma informa√ß√£o acima. O contrato ent√£o guarda quem esta aprovado para pegar o token, normalmente um mapping (uint256 => address). Ent√£o quando algu√©m chamar takeOwnership, o contrato checa se o msg.sender esta aprovado pelo dono para pegar o token, se estiver transfere o token para ele.

Se voc√™ notar, ambos transfer e takeOwnership ir√£o conter a mesma l√≥gica de transfer√™ncia, em ordem inversa. (Em um caso o remetente do token chama a fun√ß√£o; na outra o destinat√°rio do token a chama).

Ent√£o faz sentido abstrairmos esta l√≥gica em uma fun√ß√£o privada, _transfer, que ent√£o ser√° chamada por ambas fun√ß√µes. Desta maneira n√£o precisamos repetir o mesmo c√≥digo duas vezes.



Cap√≠tulo 7: ERC721: Approve

Agora, vamos implementar approve.

Lembre-se, com approve / takeOwnership, a transfer√™ncia acontece em 2 passos:

    Voc√™, o dono, chama approve e informa o address do novo dono, e o _tokenId que voc√™ quer ele pegue

    O novo dono chama takeOwnership com o _tokenId, o contrato verifica para certeza que ele j√° foi aprovado, e ent√£o transfer a ele o token.

Por que isto acontece em 2 chamadas de fun√ß√µes, precisamos de uma estrutura de dados para guardar quem esta sendo aprovado para que entre as chamadas das fun√ß√µes.


Cap√≠tulo 8: ERC721: takeOwnership

√ìtimo, agora vamos terminar a nossa implementa√ß√£o do ERC721 com a √∫ltima fun√ß√£o! (N√£o se preocupe, ainda h√° a mais para cobrir na Li√ß√£o 5 ap√≥s isso üòâ)

A fun√ß√£o final, takeOwnership, deve simplesmente verificar o msg.sender para ter certeza que foi aprovado para pegar este token / zumbi, e chamar _transfer se ok.



Cap√≠tulo 9: Prevenindo Overflows

Parab√©ns, isto conclui a nossa implementa√ß√£o do ERC721!

Isso n√£o foi t√£o dif√≠cil, foi? Um monte destas coisas em Ethereum soa complicado quando voc√™ ouve as pessoas falando, ent√£o a melhor maneira de entender √© na verdade ir implementar voc√™ mesmo.

Tenha em mente que isto √© o m√≠nimo de implementa√ß√£o. Existem recursos extras que queremos adicionar a nossa implementa√ß√£o, como algumas checagem extras para ter certeza que os usu√°rios acidentalmente n√£o transfiram os zumbis para o endere√ßo 0 (que √© conhecido como "queimando" um token ‚Äì basicamente enviado para um endere√ßo que ningu√©m tem a chave privada, essencialmente tornando-o irrecuper√°vel). Ou colocar uma l√≥gica b√°sica de um leil√£o na pr√≥pria DApp (Voc√™ consegue pensar em algumas maneiras de implementar-mos isto?)

Mas queremos manter esta li√ß√£o manej√°vel, ent√£o fomos com a l√≥gica de implementa√ß√£o mais b√°sica. Se voc√™ quiser ver um exemplo de uma implementa√ß√£o mais √† fundo, voc√™ pode dar uma olhada no contrato ERC721 do OpenZeppelin ap√≥s este tutorial.
Melhorias de seguran√ßa no contrato: Overflows e Underflows

Vamos olhar para um dos principais recursos de seguran√ßa que voc√™ deve estar ciente ao escrever smart contracts: Preven√ß√£o de overflows e underflows.

O que √© um overflow (transbordamento) ?

Digamos que voc√™ tem um uint8, que pode ter somente 8 bits. Isso significa que o maior n√∫mero que podemos guardar √© o bin√°rio 11111111 (ou um decimal, 2^8 - 1 = 255).

De uma olhada no seguinte c√≥digo. Qual √© o number igual no final?

uint8 number = 255;
number++;

Neste caso, n√≥s causamos um "overflow" ‚Äì ent√£o o number √© contraintuitivamente igual a 0 mesmo ap√≥s n√≥s aumentarmos. (Se voc√™ adicionar 1 para um bin√°rio 11111111, ele restabelece de volta para 00000000, como um rel√≥gio indo de 23:59 para 00:00).

Um "underflow" √© parecido, onde se voc√™ subtrair 1 de um uint8 que √© igual a 0, este agora √© igual √† 255 (porque uints s√£o sem sinal, e n√£o podem ser negativos).

Enquanto n√£o usamos uint8 aqui, parece improv√°vel que o uint256 ir√° transbordar quando incrementarmos em 1 toda vez (2^256 √© realmente um n√∫mero grande), ainda √© bom colocar prote√ß√µes em nossos contratos ent√£o nossa DApp nunca ter√° um comportamento indesej√°vel no futuro.
Usando SafeMath

Para prevenir isto, OpenZeppelin criou uma library (biblioteca) chamada SafeMath que previne estes erros por padr√£o.

Mas antes de disso... O que √© uma biblioteca?

Uma biblioteca √© tipo especial de contrato em Solidity. Uma das coisas que s√£o √∫teis para anexar fun√ß√µes em tipos de dados nativos.

Por exemplo, como a biblioteca SafeMath, podemos usar a sintaxe using SafeMath for uint256. A biblioteca SafeMath tem 4 fun√ß√µes ‚Äì add (adi√ß√£o), sub (subtra√ß√£o), mul (multiplica√ß√£o) e div (divis√£o). E como n√≥s podemos acessar essas fun√ß√µes de uint256 conforme segue:

using SafeMath for uint256;

uint256 a = 5;
uint256 b = a.add(3); // 5 + 3 = 8
uint256 c = a.mul(2); // 5 * 2 = 10

Vamos ver o que estas fun√ß√µes fazem no pr√≥ximo cap√≠tulo, mas por agora vamos adicionar a biblioteca SafeMath em nosso contrato.


Cap√≠tulo 10: SafeMath Parte 2

Vamos dar uma olhada no c√≥digo por tr√°s da SafeMath:

library SafeMath {

  function mul(uint256 a, uint256 b) internal pure returns (uint256) {
    if (a == 0) {
      return 0;
    }
    uint256 c = a * b;
    assert(c / a == b);
    return c;
  }

  function div(uint256 a, uint256 b) internal pure returns (uint256) {
    // assert(b > 0); // Solidity automaticamente lan√ßa uma exce√ß√£o quando dividindo por 0
    uint256 c = a / b;
    // assert(a == b * c + a % b); // N√£o h√° nenhum caso que isso n√£o contenha
    return c;
  }

  function sub(uint256 a, uint256 b) internal pure returns (uint256) {
    assert(b <= a);
    return a - b;
  }

  function add(uint256 a, uint256 b) internal pure returns (uint256) {
    uint256 c = a + b;
    assert(c >= a);
    return c;
  }
}

Primeiro n√≥s temos a palavra reservada library (biblioteca) ‚Äì bibliotecas s√£o similares a contracts mas com poucas diferen√ßas. Para nosso prop√≥sito, bibliotecas permitem-nos o uso da palavra reservada using, que automaticamente acrescenta todos os m√©todos da biblioteca em outro tipo de dado:

using SafeMath for uint;
// agora podemos usar estes m√©todos em qualquer uint
uint test = 2;
test = test.mul(3); // test agora √© igual a 6
test = test.add(5); // test agora √© igual a 11

Note que as fun√ß√µes mul e add cada uma requer 2 argumentos, mas quando n√≥s declaramos using SafeMath for uint, o uint que chamamos a fun√ß√£o (test) √© automaticamente passado como o primeiro argumento.

Vamos dar uma olhada no c√≥digo por de tr√°s de add para ver o que SafeMath faz:

function add(uint256 a, uint256 b) internal pure returns (uint256) {
  uint256 c = a + b;
  assert(c >= a);
  return c;
}

Basicamente add s√≥ adiciona 2 uints como +, mas este tamb√©m contem uma declara√ß√£o assert para ter certeza que a soma √© maior do que a. Isto nos protege contra overflows.

assert √© similar o require, onde este ir√° lan√ßar um erro se falso. A diferen√ßa entre assert e require √© que require ir√° reembolsar o usu√°rio o resto do seu g√°s quando a fun√ß√£o falhar, enquanto que assert n√£o ir√°. Ent√£o a maior parte do tempo voc√™ quer usar o require em seu c√≥digo; assert √© tipicamente usando quando algo de terr√≠vel houve com o c√≥digo (como um uint transbordar).

Ent√£o, simplesmente use, As fun√ß√µes add, sub, mul e div da SafeMath que fazem as 4 opera√ß√µes matem√°ticas b√°sicas, mas lan√ßam um erro se um overflow ou underflow ocorrer.
Usando SafeMath em nosso c√≥digo.

Para prevenir overflow and underflow, podemos procurar por lugares em nosso c√≥digo onde usamos +, -, *, or /, e substitu√≠-los por add, sub, mul e div.

Ex: Ao inv√©s de fazer:

myUint++;

N√≥s dever√≠amos fazer:
myUint = myUint.add(1);


Cap√≠tulo 11: SafeMath Parte 3

√ìtimo, agora nossa implementa√ß√£o ERC721 esta segura de overflows & underflows!

Voltando ao c√≥digo que escrevemos em li√ß√µes anteriores, existem uns poucos outros lugares onde o nosso c√≥digo poderia estar vulner√°vel a overflows ou underflows.

Por exemplo, em ZombieAttack n√≥s temos:

myZombie.winCount++;
myZombie.level++;
enemyZombie.lossCount++;

Dever√≠amos prevenir overflows aqui tamb√©m s√≥ para estar seguro. (√â uma boa ideia em geral s√≥ usar SafeMath ao inv√©s de usar opera√ß√µes matem√°ticas b√°sicas. Talvez em vers√µes futuras de Solidity estes estejam implementados por padr√£o, mas por agora n√≥s temos que ter precau√ß√£o extra com a seguran√ßa em nosso c√≥digo).

Por√©m temos um leve problema ‚Äì winCount e lossCount s√£o uint16, e level √© um uint32. Ent√£o se n√≥s usarmos o m√©todo add da SafeMath com estes argumentos, este n√£o nos proteger√£o de overflows uma vez que isto ir√° converter estes tipos para uint256:

function add(uint256 a, uint256 b) internal pure returns (uint256) {
  uint256 c = a + b;
  assert(c >= a);
  return c;
}

// Se n√≥s chamarmos `.add` em um `uint8`, este ser√° convertido para um `uint256`.
// Ent√£o este n√£o ter√° um overflow em 2^8, uma vez que um valor 256 √© valido para um `uint256`.

Isto significa que teremos que implementar 2 bibliotecas a mais para prevenir overflows/underflows com os nossos uint16 e uint32. Iremos cham√°-las de SafeMath16 e SafeMath32.

O c√≥digo ser√° exatamente o mesmo que SafeMath, exceto todas inst√¢ncias de uint256 ser√£o substitu√≠das com uint32 ou uint16.

N√≥s sa√≠mos na frente e implementamos o c√≥digo pra voc√™ ‚Äì v√° em frente e veja em safemath.sol para ver o c√≥digo.

Agora precisamos implementar em ZombieFactory.


Cap√≠tulo 12: SafeMath Parte 4

√ìtimo, agora podemos implementar SafeMath em todos os tipos de uint que usamos em nossa DApp!

Vamos consertar todos esse pot√™ncias problemas em ZombieAttack. (Ainda h√° um zombies[_zombieId].level++; que precisa ser consertado em ZombieHelper, mas n√≥s cuidamos deste pra voc√™ ent√£o n√≥s n√£o precisamos de um cap√≠tulo extra üòâ).



Cap√≠tulo 13: Coment√°rios

O c√≥digo Solidity para o nosso jogo zumbi finalmente terminou!

Nas pr√≥ximas li√ß√µes, iremos olhar em como implantar o c√≥digo no Ethereum, e como interagir com ele usando a Web3.js.

Mas uma coisa final antes de deix√°-lo ir na Li√ß√£o 5: Vamos falar sobre comentando o seu c√≥digo.
Sintaxe para coment√°rios

Comentando um c√≥digo em Solidity e como em JavaScript. Voc√™ j√° viu alguns exemplos de uma simples linha de coment√°rio nas li√ß√µes do CryptoZombies.

// Este √© um coment√°rio de uma linha. √â tipo uma nota pr√≥pria (ou para outros)

Somente adicione duas // em qualquer lugar e voc√™ esta comentando. √â t√£o f√°cil que voc√™ deveria fazer toda hora.

Mas eu entendo voc√™ ‚Äì algumas vezes uma linha n√£o √© o suficiente. Voc√™ nasceu um escritor, afinal!

Assim, n√≥s tamb√©m temos coment√°rios multi-linhas:

contract CryptoZombies {
  /* Este √© um coment√°rio multi-linha. Eu gostaria de agradecer √† todos voc√™s
    que usaram o seu tempo para tentar este curso de programa√ß√£o.
    Eu sei que √© gr√°tis para todos voc√™s, e continuar√° gr√°tis
    para sempre, mas ainda colocamos nossos cora√ß√µes e almas para fazer
    isto t√£o bom quanto o poss√≠vel.

    Saiba que este ainda √© o in√≠cio do desenvolvimento do Blockchain.
    Chegamos muito longe, mas ainda existem v√°rias maneiras de fazer esta
    comunidade melhor. Se cometemos um erro em algum lugar, voc√™ pode
    nos ajudar e abrir um pull request aqui:
    https://github.com/loomnetwork/cryptozombie-lessons

    Ou se voc√™ tiver algumas ideias, coment√°rios, ou s√≥ dizer um Ol√° ‚Äì
    envie pela nossa comunidade Telegram em https://t.me/loomnetworkdev
  */
}

Em particular, √© uma boa pr√°tica comentar o seu c√≥digo para explicar o comportamento esperado de cada fun√ß√£o em seu contrato. Desta maneira outro desenvolvedor (ou voc√™, ap√≥s seis meses de hiato de um projeto!) pode rapidamente ler e entender em alto n√≠vel o que seu c√≥digo faz sem ter que ler o pr√≥prio c√≥digo.

O padr√£o na comunidade Solidity √© usar o formato chamado natspec, que se parece com isso:

/// @title Um contrato para opera√ß√µes b√°sicas de matem√°tica
/// @author H4XF13LD MORRIS üíØüíØüòéüíØüíØ
/// @notice No momento, este contrato somente adiciona uma fun√ß√£o de multiplica√ß√£o
contract Math {
  /// @notice Multiplica dois n√∫meros juntos
  /// @param x o primeiro uint.
  /// @param y o segundo uint.
  /// @return z o produto de (x * y)
  /// @dev Esta fun√ß√£o n√£o atualmente n√£o checa por overflows
  function multiply(uint x, uint y) returns (uint z) {
    // Este √© somente um coment√°rio normal, e n√£o sera lido pelo natspec
    z = x * y;
  }
}

@title e @author s√£o simples.

@notice explica para o usu√°rio o que o contrato / fun√ß√£o faz. @dev √© para explicar detalhes extras para os desenvolvedores.

@param e @return s√£o para descrever o que cada par√¢metro e valor de retorno da fun√ß√£o fazem.

Note que voc√™ n√£o precisa ter que usar todas essas tags para cada fun√ß√£o - todas as tags s√£o opcionais. Mas pelo menos, deixa uma nota com @dev explicando o que cada fun√ß√£o faz.





